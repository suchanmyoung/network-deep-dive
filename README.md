# network-deep-dive
#### 네트워크 관련 서적들의 내용을 발췌하여 정리하였으며 출처는 하단에 명시하였음.

<details>
<summary>TCP(Transfer Control Protocol)</summary>

TCP는 트랜스포트 계층에 해당하며 신뢰성 있는 바이트 스트림 서비스를 제공 한다. 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 하는 단위 패킷으로 작게 분해하여 관리하는 것을 말한다. 결국 TCP는 대용량의 데이터를 작게 분해해서 보내고, 정확하게 도착했는지 확인하는 역할을 담당한다.

</details>

<details>
<summary>3-way handshaking</summary>

TCP는 상대방에게 정확하게 데이터를 보내기 위해 3-way handshaking 방법을 사용하는데, 이 방법은 패킷을 보내고 바로 끝내는 것이 아니라 보내졌는지 여부를 'SYN', 'ACK' 이라는 TCP 플래그를 사용하여 확인한다.

SYN 패킷 전송(송신 측) > SYN/ACK 패킷 전송(수신 측) > ACK 전송(송신 측)

만약 핸드셰이킹 과정에서 도중에 통신이 끈헝지면 TCP는 같은 수순으로 패킷을 재전송한다.

</details>

<details>
<summary>HTTP 지속 연결</summary>

HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결과 접속을 종료할 필요가 있었다. 초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도여서 문제가 없었다.

하지만 요청한 하나의 HTML에 여러 이미지가 포함되어 있는 경우 HTTP 요청 시에 HTML 문서에 포함되어 있는 이미지를 획득하기 위해서 내부 이미지만큼의 리퀘스트를 송신하는데, 그때마다 TCP 연결/종료가 발생하여 불필요한 통신량이 생긴다. HTTP/1.0 이후에 지속 연결(Persistent Connections)이라는 방법이 고안되었는데, 이는 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

이러한 지속 연결 방식을 통해, 여러 리퀘스트를 보낼 수 있도록 HTTP pipelining 이 가능해지는데, 이전에는 요청 후에 응답을 기다려야 했다면 이제는 요청 후에도 수신을 기다리지않고 바로 다음 리퀘스트를 보낼 수 있게 된다.
</details>

<details>
<summary>쿠키(Cookie)</summary>

HTTP는 stateless 프로토콜이기 때문에 과거의 상태를 관리하지 않아 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있고 단순함으로 다양한 곳에서 이용할 수 있다.

무상태의 단점(인증 등의 관리)를 보안하기 위해 쿠키라는 시스템이 도입되었는데, 쿠키라는 헤더 필드를 통해 상태를 관리할 수 있다.

</details>

<details>
<summary>범위 요청(Range Request)</summary>

대용량의 이미지와 데이터를 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드 해야 한다. 이런 문제를 해결하기 위해 resume 기능을 통해 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있는데, 엔티티의 범위를 지정해서 다운로드 할 필요가 있다. 이 같이 범위를 지정해서 요청 하는 것을 Range Request 라고 한다.

</details>

<details>
<summary>컨텐츠 협상(Content Negotiation)</summary>

클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다. 영어판 브라우저에서는 Google 영문 페이지를, 한국판 브라우저에서는 Google 한국어 페이지를 응답하는 것이 예시이다.

컨텐츠 협상은 Accept-Charset, Accept-Encoding, Accept-Language 등의 리퀘스트 헤더 필드를 통해 판단한다. 서버 측에서 협상하는 서버 구동형, 클라이언트 측에서 협상하는 에이전트 구동형, 혼합형인 transparent 형이 있따.

</details>

<details>
<summary>상태 코드</summary>

HTTP의 응답에는 결과가 어떻게 처리되었는지 알려주는 상태 코드가 있다. 그 구성은 아래와 같다.

* 1xx(Informational) - 리퀘스트를 받아들여 처리중
* 2xx(Success) - 리퀘스트를 정상적으로 처리했음
  * 200(OK)
  * 204(No Content) - 처리에 성공했지만 응답에 엔티티 바디를 포함하지 않음
  * 206(Partial Content) - Range Request 에 의해 서버가 부분적 리퀘스트를 받았음
* 3xx(Redirection) - 리퀘스트를 완료하기 위해서 추가 동작이 필요
  * 300번대 리스폰드 코드가 되돌아 오면 대부분의 브라우저에서는 리퀘스트를 자동적으로 재송신하도록 되어 있음
* 4xx(Client Error) - 서버가 리퀘스트를 이해할 수 없음
  * 400(Bad Request) - 리퀘스트 구문이 잘못 되었음
  * 401(UnAuthorized) - 인증 실패
  * 403(Forbidden) - 인가 실패
  * 404(Not Found) - 리소스가 서버 상에 없음
* 5xx(Server Error) - 서버가 리퀘스트 처리 실패
  * 500(Internal Server Error) - 서버에서 리퀘스트를 처리 중에 에러가 발생 했음
  * 503(Service Unavailable) - 일시적으로 서버가 과부하 상태이거나 점검 중

**하지만 상태 코드가 현재 상황과 불일치 할 수도 있다. 상태 코드의 대부분은 유저가 다른 내용을 알기 어렵게 되어 있기 때문이다.**

</details>

<details>
<summary>프록시 서버(Proxy Server)</summary>

프록시 서버는 서버와 클라이언트의 양쪽 역할을 하는 중계 서버로, 클라이언트로부터의 리퀘스트를 서버에 전송하고, 서버로부터의 리스폰스를 클라이언트에게 전송한다.

HTTP 통신에서 프록시 서버를 여러 대 경유하는 것도 가능한데, 이럴 때에는 Via 헤드 필드에 경유한 호스트 정보를 추가해야 한다.

프록시 서버를 경유하는 이유는 캐시를 사용해서 네트워크 대역 등을 효율적으로 사용하거나 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 지키기 위해서이다.
</details>

<details>
<summary>게이트웨이(Gateway)</summary>

게이트웨이의 동작은 프록시와 유사하지만, 게이트웨이의 경우에는 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다.암호화 등의 방법을 통해 안전하게 접속하여 통신의 안전성을 높이는 역할 등을 한다.

</details>

<details>
<summary>캐시 서버(Cache Server)</summary>

캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류된다. 프록시가 서버로부터의 리스폰스를 중계하는 때에 프록시 서버 상에 리소스의 사본을 보존한다.

</details>


출처.
* 그림으로 배우는 HTTP Network BASIC, 우에노 센