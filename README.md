# network-deep-dive
#### 네트워크 관련 서적들의 내용을 발췌하여 정리하였으며 출처는 하단에 명시하였음.

<details>
<summary>TCP(Transfer Control Protocol)</summary>

TCP는 트랜스포트 계층에 해당하며 신뢰성 있는 바이트 스트림 서비스를 제공 한다. 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 하는 단위 패킷으로 작게 분해하여 관리하는 것을 말한다. 결국 TCP는 대용량의 데이터를 작게 분해해서 보내고, 정확하게 도착했는지 확인하는 역할을 담당한다.

</details>

<details>
<summary>3-way handshaking</summary>

TCP는 상대방에게 정확하게 데이터를 보내기 위해 3-way handshaking 방법을 사용하는데, 이 방법은 패킷을 보내고 바로 끝내는 것이 아니라 보내졌는지 여부를 'SYN', 'ACK' 이라는 TCP 플래그를 사용하여 확인한다.

SYN 패킷 전송(송신 측) > SYN/ACK 패킷 전송(수신 측) > ACK 전송(송신 측)

만약 핸드셰이킹 과정에서 도중에 통신이 끈헝지면 TCP는 같은 수순으로 패킷을 재전송한다.

</details>

### HTTP
<hr>
<details>
<summary>HTTP 지속 연결</summary>

HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결과 접속을 종료할 필요가 있었다. 초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도여서 문제가 없었다.

하지만 요청한 하나의 HTML에 여러 이미지가 포함되어 있는 경우 HTTP 요청 시에 HTML 문서에 포함되어 있는 이미지를 획득하기 위해서 내부 이미지만큼의 리퀘스트를 송신하는데, 그때마다 TCP 연결/종료가 발생하여 불필요한 통신량이 생긴다. HTTP/1.0 이후에 지속 연결(Persistent Connections)이라는 방법이 고안되었는데, 이는 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

이러한 지속 연결 방식을 통해, 여러 리퀘스트를 보낼 수 있도록 HTTP pipelining 이 가능해지는데, 이전에는 요청 후에 응답을 기다려야 했다면 이제는 요청 후에도 수신을 기다리지않고 바로 다음 리퀘스트를 보낼 수 있게 된다.
</details>

<details>
<summary>쿠키(Cookie)</summary>

HTTP는 stateless 프로토콜이기 때문에 과거의 상태를 관리하지 않아 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있고 단순함으로 다양한 곳에서 이용할 수 있다.

무상태의 단점(인증 등의 관리)를 보안하기 위해 쿠키라는 시스템이 도입되었는데, 쿠키라는 헤더 필드를 통해 상태를 관리할 수 있다.

쿠키는 HTTP/1.1의 사양인 RFC2616에 포함된 것은 아니다.

한번 서버에 송출한 클라이언트의 쿠키는 서버에서 명시적으로 삭젷나느 방법은 없고, 유효 기간이 지났따면 쿠키를 덮어쓰는 것으로 실질적은 클라이언트 측의 쿠키를 삭제한다. Expires 속성을 생략하면 브라우저 세션이 유지되는 경우에만 유효하다.

</details>

<details>
<summary>범위 요청(Range Request)</summary>

대용량의 이미지와 데이터를 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드 해야 한다. 이런 문제를 해결하기 위해 resume 기능을 통해 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있는데, 엔티티의 범위를 지정해서 다운로드 할 필요가 있다. 이 같이 범위를 지정해서 요청 하는 것을 Range Request 라고 한다.

</details>

<details>
<summary>컨텐츠 협상(Content Negotiation)</summary>

클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다. 영어판 브라우저에서는 Google 영문 페이지를, 한국판 브라우저에서는 Google 한국어 페이지를 응답하는 것이 예시이다.

컨텐츠 협상은 Accept-Charset, Accept-Encoding, Accept-Language 등의 리퀘스트 헤더 필드를 통해 판단한다. 서버 측에서 협상하는 서버 구동형, 클라이언트 측에서 협상하는 에이전트 구동형, 혼합형인 transparent 형이 있따.

</details>

<details>
<summary>상태 코드</summary>

HTTP의 응답에는 결과가 어떻게 처리되었는지 알려주는 상태 코드가 있다. 그 구성은 아래와 같다.

* 1xx(Informational) - 리퀘스트를 받아들여 처리중
* 2xx(Success) - 리퀘스트를 정상적으로 처리했음
  * 200(OK)
  * 204(No Content) - 처리에 성공했지만 응답에 엔티티 바디를 포함하지 않음
  * 206(Partial Content) - Range Request 에 의해 서버가 부분적 리퀘스트를 받았음
* 3xx(Redirection) - 리퀘스트를 완료하기 위해서 추가 동작이 필요
  * 300번대 리스폰드 코드가 되돌아 오면 대부분의 브라우저에서는 리퀘스트를 자동적으로 재송신하도록 되어 있음
* 4xx(Client Error) - 서버가 리퀘스트를 이해할 수 없음
  * 400(Bad Request) - 리퀘스트 구문이 잘못 되었음
  * 401(UnAuthorized) - 인증 실패
  * 403(Forbidden) - 인가 실패
  * 404(Not Found) - 리소스가 서버 상에 없음
* 5xx(Server Error) - 서버가 리퀘스트 처리 실패
  * 500(Internal Server Error) - 서버에서 리퀘스트를 처리 중에 에러가 발생 했음
  * 503(Service Unavailable) - 일시적으로 서버가 과부하 상태이거나 점검 중

**하지만 상태 코드가 현재 상황과 불일치 할 수도 있다. 상태 코드의 대부분은 유저가 다른 내용을 알기 어렵게 되어 있기 때문이다.**

</details>

<details>
<summary>HTTP의 약점</summary>

* HTTP의 요청과 응답 내용은 HTTP 자신을 암호화하는 기능은 없기 때문에 통신 전체가 암호화 되지는 않는다. 즉, 도청이 가능하다. 암호화되지 않은 통신이 약점인 이유는 TCP/IP 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있기 때문이다. 암호화하더라도 암호화된 메세지 자체는 확인할 수 있다.
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다
* 누구나 요청할 수 있다(Ddos)
* 발신된 요청과 응답이 수신한 요청과 응답과 같은지 아닌지 확인할 수 없다(Man-in-the-Middle Attack)

이러한 약점들을 보완하기 위해 **HTTPS**를 사용한다.
</details>

<details>
<summary>HTTPS와 암호화 이야기</summary>

HTTP에는 암호화 구조가 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL 등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 한다. SSL을 조합한 HTTP를 HTTPS 라고 한다.

HTTP에서는 통신 상대를 확인할 수 없지만 SSL은 상대를 확인할 수 있다. SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다. 클라이언트가 통신을 개시할 때 서버의 증명서를 확인하여 상대를 확인한다.

HTTPS는 HTTP + 암호화 + 인증 + 완전성 보호(요청의 정확성)을 합친 것이다. HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아니고, HTTP 통신의 소켓 부분을 SSL 혹은 TLS 프로토콜로 대체하는 방식으로 구현된다. 보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용하는 경우에는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다.

암호화와 복호화에 하나의 키를 사용하는 방식을 공통키라고 부른다. 하지만 공격자에게 키를 빼앗기게 되면 보안의 큰 허점이 생긴다. 이 때문에 공개키 암호화 방식이 생겼다. 공개키를 통해 암호화하고 복호화할 때는 비밀키를 이용하는 방식이다.

HTTPS는 공통키 암호화와 공개키 암호화의 양쪽 성질을 가진 하이브리드 암호 시스템을 사용한다. 키를 교환하는 곳에서는 공개키 암호화를, 그 후의 통신에서 메세지를 교환할 때는 공통키 암호화(단순하지만 처리 속도가 빠름)를 사용한다.

하지만 공개키의 문제점은, 공개키가 진짜인지 아닌지를 증명할 수 없다는 것이다. 이 문제를 해결 하기 위해 인증 기관(CA:Certificate Authority)과 CA가 발행하는 공개키 증명서가 이용되고 있다. CA는 아래와 같이 이용된다.

서버의 운영자가 CA에 공개키 제출 > CA는 공개키에 디지털 서명을 하여 공개키 생성 > 공개키 인증서에 공개키를 담음 > 서버는 해당 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신(*인증기관의 공개키는 사전에 브라우저에 내장되어 있음*) 

OpenSSL 등의 소프트웨어를 사용하면 누구든지 인증 기관을 구축하여 서버 증명서를 발행할 수 있지만, 이는 아무런 구실을 못하며 쓸모가 없다. '나야 나' 증명서를 사용하더라도 SSL로 암호화되고 있기 때문에 통신은 안전하다는 설명을 가끔 볼 수 있는데, 통신은 암호화되어 있어도 위장하고 있는 가짜 서버와 통신하고 있을 가능성이 있따.

HTTPS에도 문제는 있는데, 바로 SSL을 사용하면 서버,클라이언트 모두 암호화와 복호화 처리가 필요하여 CPU나 메모리 등의 리소스를 소비하기 때문에 처리가 늦어진다는 것이다. 네트워크의 부하는 HTTP를 사용하는 경우에 비해 2배에서 100배까지도 느려진다.
</details>

<details>
<summary>HTTP 확장 프로토콜, SPDY</summary>

구글에서 발표한 SPDY는 HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발되고 있다. SNS에서는 단시간에 대량의 갱신 정보가 발생하는데, 갱신된 정보를 가능한 빨리 실시간으로 표시하기 위해서는 서버상의 정보가 갱신되었을 때 클라이언트의 화면에 반영할 필요가 있다. 이는 단순하지만 HTTP에서는 처리할 수 없다. 한 개의 커넥션으로 한 개의 요청, 응답만 받는 것은 불가능 등이 이유다. Comet으로 응답을 보류 상태에 두면서 컨텐츠를 실시간 갱신할 수는 있지만, 이를 위해 커넥션을 유지하는 시간이 길어진다.

SPDY는 애플리케이션 계층(HTTP)과 트랜스포트 계층(TCP) 사이에 새로운 세션 계층을 추가하는 형태로 동작한다. SPDY를 사용하면 단일 TCP 접속으로 복수의 HTTP 요청을 무제한 처리할 수 있으며 우선순위를 할당할 수도 있다. 요청과 응답 헤더를 압축하고, 서버에서 클라이언트로 푸시를 보낼 수 있다.

**책과는 별도로, 현재는 SPDY는 HTTP 2.0에 밀려 크롬 브라우저에서 제거되었으며 HTTP 2.0의 규격에 참고로 사용 되었다.**

</details>



<details>
<summary>프록시 서버(Proxy Server)</summary>

프록시 서버는 서버와 클라이언트의 양쪽 역할을 하는 중계 서버로, 클라이언트로부터의 리퀘스트를 서버에 전송하고, 서버로부터의 리스폰스를 클라이언트에게 전송한다.

HTTP 통신에서 프록시 서버를 여러 대 경유하는 것도 가능한데, 이럴 때에는 Via 헤드 필드에 경유한 호스트 정보를 추가해야 한다.

프록시 서버를 경유하는 이유는 캐시를 사용해서 네트워크 대역 등을 효율적으로 사용하거나 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 지키기 위해서이다.
</details>

<details>
<summary>게이트웨이(Gateway)</summary>

게이트웨이의 동작은 프록시와 유사하지만, 게이트웨이의 경우에는 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다.암호화 등의 방법을 통해 안전하게 접속하여 통신의 안전성을 높이는 역할 등을 한다.

</details>

<details>
<summary>캐시 서버(Cache Server)</summary>

캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류된다. 프록시가 서버로부터의 리스폰스를 중계하는 때에 프록시 서버 상에 리소스의 사본을 보존한다.

</details>


출처.
* 그림으로 배우는 HTTP Network BASIC, 우에노 센